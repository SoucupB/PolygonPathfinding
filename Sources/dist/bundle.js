/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = earcut;\nmodule.exports[\"default\"] = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack://polygon-pathfinding/./node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./Geometry/Line.js":
/*!**************************!*\
  !*** ./Geometry/Line.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nlet lineIndex = 0;\nclass Line {\n  constructor(pointA, pointB, id = 0) {\n    this.pointA = pointA;\n    this.pointB = pointB;\n    this.id = lineIndex++;\n  }\n  jointPoints(line) {\n    let points = [];\n    let pointALine = [this.pointA, this.pointB];\n    let pointBLine = [line.pointA, line.pointB];\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < 2; j++) {\n        if (pointALine[i].arePointsEqual(pointBLine[j])) {\n          points.push(pointALine[i]);\n        }\n      }\n    }\n    return points;\n  }\n  areLinesEqual(lineA) {\n    return this.jointPoints(lineA).length == 2;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Line);\n\n//# sourceURL=webpack://polygon-pathfinding/./Geometry/Line.js?");

/***/ }),

/***/ "./Geometry/Navmesh.js":
/*!*****************************!*\
  !*** ./Geometry/Navmesh.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var _Triangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Triangle.js */ \"./Geometry/Triangle.js\");\n\n\nclass Navmesh {\n  constructor(polygon) {\n    this.triangles = [];\n    this.polygon = polygon;\n    this.triangleID = 0;\n  }\n  createTriangles(triangleIndexes) {\n    const points = this.polygon;\n    for (let i = 0, c = triangleIndexes.length; i < c; i += 3) {\n      this.triangles.push(new _Triangle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](points[triangleIndexes[i]], points[triangleIndexes[i + 1]], points[triangleIndexes[i + 2]], this.triangleID++));\n    }\n  }\n  createNeighbours() {\n    let triangleCheck = {};\n    if (!this.triangles.length) {\n      return;\n    }\n    this.createNeighbours_t(this.triangles[0], triangleCheck);\n  }\n  createNeighbours_t(currentTriangle, triangleCheck = {}) {\n    if (currentTriangle.id in triangleCheck) {\n      return;\n    }\n    triangleCheck[currentTriangle.id] = 1;\n    for (let i = 0, c = this.triangles.length; i < c; i++) {\n      if (this.triangles[i].id != currentTriangle.id && currentTriangle.areTriangleNeighbours(this.triangles[i])) {\n        currentTriangle.neighbours.push(this.triangles[i]);\n      }\n    }\n    for (let i = 0, c = currentTriangle.neighbours.length; i < c; i++) {\n      this.createNeighbours_t(currentTriangle.neighbours[i], triangleCheck);\n    }\n  }\n  triangulate() {\n    let coords = [];\n    for (let i = 0; i < this.polygon.length - 1; i++) {\n      coords.push(this.polygon[i].y);\n      coords.push(this.polygon[i].x);\n    }\n    this.createTriangles(earcut__WEBPACK_IMPORTED_MODULE_0__(coords));\n    this.createNeighbours();\n  }\n  getTriangle(point) {\n    const triangles = this.triangles;\n    for (let i = 0, c = triangles.length; i < c; i++) {\n      if (triangles[i].isPointInside(point)) {\n        return triangles[i];\n      }\n    }\n    return null;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Navmesh);\n\n//# sourceURL=webpack://polygon-pathfinding/./Geometry/Navmesh.js?");

/***/ }),

/***/ "./Geometry/Point.js":
/*!***************************!*\
  !*** ./Geometry/Point.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Point {\n  constructor(y, x) {\n    this.y = y;\n    this.x = x;\n  }\n  arePointsEqual(point) {\n    return Math.abs(point.x - this.x) <= 1e-5 && Math.abs(point.y - this.y) <= 1e-5;\n  }\n  distancef(point) {\n    return Math.sqrt((this.x - point.x) * (this.x - point.x) + (this.y - point.y) * (this.y - point.y));\n  }\n  static areSegmentsIntersecting(A, B, C, D) {\n    const orientation = (p, q, r) => {\n      const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n      if (val === 0) return 0;\n      return val > 0 ? 1 : 2;\n    };\n    const onSegment = (p, q, r) => {\n      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n    };\n    const o1 = orientation(A, B, C);\n    const o2 = orientation(A, B, D);\n    const o3 = orientation(C, D, A);\n    const o4 = orientation(C, D, B);\n    if (o1 !== o2 && o3 !== o4) {\n      return true;\n    }\n    if (o1 === 0 && onSegment(A, C, B)) return true;\n    if (o2 === 0 && onSegment(A, D, B)) return true;\n    if (o3 === 0 && onSegment(C, A, D)) return true;\n    if (o4 === 0 && onSegment(C, B, D)) return true;\n    return false;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Point);\n\n//# sourceURL=webpack://polygon-pathfinding/./Geometry/Point.js?");

/***/ }),

/***/ "./Geometry/Polygon.js":
/*!*****************************!*\
  !*** ./Geometry/Polygon.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point.js */ \"./Geometry/Point.js\");\n/* harmony import */ var _Navmesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Navmesh.js */ \"./Geometry/Navmesh.js\");\n\n\nclass Polygon {\n  constructor(points = []) {\n    this.lines = points;\n    this.holes = [];\n    this.autocompletePointDistance = 3;\n    this.complete = false;\n    this.navmesh = null;\n  }\n  _canPointBePushed(point, startingPoint = 0) {\n    if (this.lines.length <= 2) {\n      return true;\n    }\n    for (let i = startingPoint, c = this.lines.length - 2; i < c; i++) {\n      if (_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].areSegmentsIntersecting(this.lines[i], this.lines[i + 1], this.lines[c + 1], point)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  doesSegmentIntersects(start, end) {\n    for (let i = 0, c = this.lines.length; i < c; i++) {\n      if (_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].areSegmentsIntersecting(this.lines[i], this.lines[(i + 1) % c], start, end)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  push(y, x, woChecker = false) {\n    if (this.complete) {\n      return true;\n    }\n    const point = new _Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](y, x);\n    if (!woChecker && !this._canPointBePushed(point)) {\n      return false;\n    }\n    this.lines.push(point);\n    return true;\n  }\n  static print(polygon) {\n    let resp = [];\n    for (let i = 0, c = polygon.lines.length; i < c; i++) {\n      resp.push(`(${polygon.lines[i].y},${polygon.lines[i].x})`);\n    }\n    console.log(resp.join(','));\n  }\n  distancef(a, b) {\n    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n  }\n  getClosestPoint(point) {\n    for (let i = 0, c = this.lines.length - 1; i < c; i++) {\n      if (point.distancef(this.lines[i]) <= this.autocompletePointDistance) {\n        return [i, this.lines[i]];\n      }\n    }\n    return null;\n  }\n  closePolygon() {\n    if (this.complete || this.lines.length < 2) {\n      return false;\n    }\n    const point = this.lines[0];\n    if (!this._canPointBePushed(point, 1)) {\n      return false;\n    }\n    this.push(this.lines[0].y, this.lines[0].x, true);\n    this.complete = true;\n    return true;\n  }\n  getTriangle(point) {\n    return this.navmesh.getTriangle(point);\n  }\n  linesCount() {\n    return Math.max(0, this.lines.length - 1);\n  }\n  isPointInsidePolygon(point) {\n    let inside = false;\n    let polygon = this.lines;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const xi = polygon[i].x;\n      const yi = polygon[i].y;\n      const xj = polygon[j].x;\n      const yj = polygon[j].y;\n      const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  triangulate() {\n    if (!this.complete) {\n      return [];\n    }\n    this.navmesh = new _Navmesh_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.lines);\n    this.navmesh.triangulate();\n  }\n  getTriangleIndexes() {\n    if (!this.navmesh) {\n      return null;\n    }\n    return this.navmesh.triangles;\n  }\n  display() {\n    console.log(this.lines);\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polygon);\n\n//# sourceURL=webpack://polygon-pathfinding/./Geometry/Polygon.js?");

/***/ }),

/***/ "./Geometry/Triangle.js":
/*!******************************!*\
  !*** ./Geometry/Triangle.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point.js */ \"./Geometry/Point.js\");\n\nclass Triangle {\n  constructor(a, b, c, id = 0) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.id = id;\n    this.neighbours = [];\n  }\n  isPointInside(point) {\n    const [x, y] = [point.x, point.y];\n    const [x1, y1] = [this.a.x, this.a.y];\n    const [x2, y2] = [this.b.x, this.b.y];\n    const [x3, y3] = [this.c.x, this.c.y];\n    const denominator = (y2 - y3) * (x1 - x3) + (x3 - x2) * (y1 - y3);\n    const alpha = ((y2 - y3) * (x - x3) + (x3 - x2) * (y - y3)) / denominator;\n    const beta = ((y3 - y1) * (x - x3) + (x1 - x3) * (y - y3)) / denominator;\n    const gamma = 1 - alpha - beta;\n    return alpha > 0 && beta > 0 && gamma > 0;\n  }\n  _display() {\n    let stringResponse = `id: ${this.id}, neigh: `;\n    let neighIDs = [];\n    for (let i = 0, c = this.neighbours.length; i < c; i++) {\n      neighIDs.push(this.neighbours[i].id);\n    }\n    console.log(stringResponse + neighIDs.join(', '));\n  }\n  displayNeighbours(recursive = false) {\n    if (recursive) {\n      let triangleMap = {};\n      this.displayNeighbours_t(triangleMap);\n      return;\n    }\n    this._display();\n  }\n  displayNeighbours_t(trianglesChecked = {}) {\n    if (this.id in trianglesChecked) {\n      return;\n    }\n    trianglesChecked[this.id] = 1;\n    this._display();\n    for (let i = 0, c = this.neighbours.length; i < c; i++) {\n      this.neighbours[i].displayNeighbours_t(trianglesChecked);\n    }\n  }\n  midPoint() {\n    return new _Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((this.a.y + this.b.y + this.c.y) / 3.0, (this.a.x + this.b.x + this.c.x) / 3.0);\n  }\n  midDistance(triA) {\n    return this.midPoint().distancef(triA.midPoint());\n  }\n  doesTriangleHavePoint(point) {\n    return this.a.arePointsEqual(point) || this.b.arePointsEqual(point) || this.c.arePointsEqual(point);\n  }\n  disjointPoints(triangle) {\n    let points = [];\n    let trianglePoints = [this.a, this.b, this.c];\n    for (let i = 0, c = trianglePoints.length; i < c; i++) {\n      if (!triangle.doesTriangleHavePoint(trianglePoints[i])) {\n        points.push(trianglePoints[i]);\n      }\n    }\n    return points;\n  }\n  disjointPointsFromPoint(point) {\n    let points = [];\n    let trianglePoints = [this.a, this.b, this.c];\n    for (let i = 0, c = trianglePoints.length; i < c; i++) {\n      if (!point.arePointsEqual(trianglePoints[i])) {\n        points.push(trianglePoints[i]);\n      }\n    }\n    return points;\n  }\n  commonPoints(triangle) {\n    let points = [];\n    let trianglePoints = [this.a, this.b, this.c];\n    for (let i = 0, c = trianglePoints.length; i < c; i++) {\n      if (triangle.doesTriangleHavePoint(trianglePoints[i])) {\n        points.push(trianglePoints[i]);\n      }\n    }\n    return points;\n  }\n  areTriangleNeighbours(triB) {\n    return (this.a.arePointsEqual(triB.a) ? 1 : 0) + (this.a.arePointsEqual(triB.b) ? 1 : 0) + (this.a.arePointsEqual(triB.c) ? 1 : 0) + (this.b.arePointsEqual(triB.a) ? 1 : 0) + (this.b.arePointsEqual(triB.b) ? 1 : 0) + (this.b.arePointsEqual(triB.c) ? 1 : 0) + (this.c.arePointsEqual(triB.a) ? 1 : 0) + (this.c.arePointsEqual(triB.b) ? 1 : 0) + (this.c.arePointsEqual(triB.c) ? 1 : 0) >= 2;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Triangle);\n\n//# sourceURL=webpack://polygon-pathfinding/./Geometry/Triangle.js?");

/***/ }),

/***/ "./Searcher/AStar.js":
/*!***************************!*\
  !*** ./Searcher/AStar.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Heap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Heap.js */ \"./Searcher/Heap.js\");\n\nclass AStar {\n  constructor(generateNeighbours, uniqueID, edgeCost) {\n    this.generateNeighbours = generateNeighbours;\n    this.uniqueID = uniqueID;\n    this.edgeCost = edgeCost;\n    this.heap = new _Heap_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((a, b) => {\n      return a.cost < b.cost;\n    });\n    this.cost = null;\n  }\n  search(src, dst) {\n    this.heap.push({\n      node: src,\n      cost: 0,\n      parent: null\n    });\n    return this.search_t(dst);\n  }\n  retrieveNodes(dst) {\n    let nodes = [];\n    while (dst) {\n      nodes.push(dst.node);\n      dst = dst.parent;\n    }\n    return nodes.reverse();\n  }\n  search_t(dst) {\n    let visited = {};\n    let costPerID = {};\n    while (this.heap.size()) {\n      let currentNode = this.heap.top();\n      const currentNodeID = this.uniqueID(currentNode.node);\n      if (this.uniqueID(dst) == currentNodeID) {\n        return this.retrieveNodes(currentNode);\n      }\n      this.heap.pop();\n      visited[currentNodeID] = true;\n      let neighbours = this.generateNeighbours(currentNode.node);\n      for (let i = 0, c = neighbours.length; i < c; i++) {\n        const neighbourID = this.uniqueID(neighbours[i]);\n        if (!(neighbourID in visited)) {\n          const currentCost = this.edgeCost(currentNode.node, neighbours[i]) + currentNode.cost;\n          if (neighbourID in costPerID && costPerID[neighbourID] < currentCost) {\n            continue;\n          }\n          this.heap.push({\n            cost: currentCost,\n            node: neighbours[i],\n            parent: currentNode\n          });\n          costPerID[neighbourID] = currentCost;\n        }\n      }\n    }\n    return null;\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AStar);\n\n//# sourceURL=webpack://polygon-pathfinding/./Searcher/AStar.js?");

/***/ }),

/***/ "./Searcher/Funnel.js":
/*!****************************!*\
  !*** ./Searcher/Funnel.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Geometry/Point.js */ \"./Geometry/Point.js\");\n/* harmony import */ var _Geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Geometry/Polygon.js */ \"./Geometry/Polygon.js\");\n/* harmony import */ var _Geometry_Line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Geometry/Line.js */ \"./Geometry/Line.js\");\n\n\n\nclass Funnel {\n  constructor() {}\n  static midLines(triangles) {\n    let points = [];\n    for (let i = 0, c = triangles.length; i < c; i++) {\n      points.push(triangles[i].midPoint());\n    }\n    return points;\n  }\n  static doesMidLineIntersecLines(st, end, midLines) {\n    for (let i = 0, c = midLines.length - 1; i < c; i++) {\n      if (_Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].areSegmentsIntersecting(st, end, midLines[i], midLines[i + 1])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static printFunnelLines(funnel) {\n    let resp = [];\n    for (let i = 0; i < funnel.length; i++) {\n      resp.push(`(${funnel[i].pointA.y},${funnel[i].pointA.x}),(${funnel[i].pointB.y},${funnel[i].pointB.x})`);\n    }\n    console.log(resp.join('\\n'));\n  }\n  static print(funnel) {\n    let resp = [];\n    let lines = funnel.lines;\n    for (let i = 0, c = lines.length; i < c; i++) {\n      resp.push(`(${lines[i].x},${lines[i].y})`);\n    }\n    console.log(resp.join(','));\n  }\n  static printTrianglePoints(triangles) {\n    let response = [];\n    for (let i = 0, c = triangles.length; i < c; i++) {\n      const triangle = triangles[i];\n      let points = [triangle.a, triangle.b, triangle.c];\n      for (let j = 0; j < points.length; j++) {\n        for (let k = j + 1; k < points.length; k++) {\n          response.push(`(${points[j].y},${points[j].x}),(${points[k].y},${points[k].x})`);\n        }\n      }\n    }\n    console.log(response.join(','));\n  }\n  static triangleToLines(triangle) {\n    let points = [triangle.a, triangle.b, triangle.c];\n    let lines = [];\n    for (let i = 0; i < 2; i++) {\n      for (let j = i + 1; j < 3; j++) {\n        lines.push(new _Geometry_Line_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](points[i], points[j]));\n      }\n    }\n    return lines;\n  }\n  static getValidLinesFromTriangle(triangles, hull = []) {\n    let allAlines = [];\n    for (let i = 0, c = triangles.length; i < c; i++) {\n      allAlines = allAlines.concat(Funnel.triangleToLines(triangles[i]));\n    }\n    for (let i = 0, c = allAlines.length; i < c; i++) {\n      let unique = 1;\n      for (let j = 0; j < c; j++) {\n        if (i != j && allAlines[i].areLinesEqual(allAlines[j])) {\n          unique = 0;\n          break;\n        }\n      }\n      if (unique) {\n        hull.push(allAlines[i]);\n      }\n    }\n  }\n  static sortHull_t(hull, lineCount, lastIndex = 0, pointsArray = []) {\n    for (let i = 0, c = hull.length; i < c; i++) {\n      const jointPoints = hull[i].jointPoints(hull[lastIndex]);\n      if (i != lastIndex && jointPoints.length == 1 && !lineCount[i]) {\n        lineCount[i] = 1;\n        pointsArray.push(jointPoints[0]);\n        Funnel.sortHull_t(hull, lineCount, i, pointsArray);\n      }\n    }\n  }\n  static sortHull(hull) {\n    let lineCount = new Array(hull.length).fill(0);\n    let pointsArray = [];\n    lineCount[0] = 1;\n    Funnel.sortHull_t(hull, lineCount, 0, pointsArray);\n    if (pointsArray[0].arePointsEqual(hull[0].pointA)) {\n      pointsArray.push(hull[0].pointB);\n    } else {\n      pointsArray.push(hull[0].pointA);\n    }\n    // Funnel.printFunnelPoints(pointsArray);\n    let polygon = new _Geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    for (let i = 0, c = pointsArray.length; i < c; i++) {\n      polygon.push(pointsArray[i].y, pointsArray[i].x);\n    }\n    polygon.closePolygon(0);\n    return polygon;\n  }\n  static searchPath(triangles) {\n    let hull = [];\n    Funnel.getValidLinesFromTriangle(triangles, hull);\n    return Funnel.sortHull(hull);\n  }\n  static rotatePoint(point, center, angle) {\n    const thetaRad = Math.PI / 180 * angle;\n    const newX = (point.x - center.x) * Math.cos(thetaRad) - (point.y - center.y) * Math.sin(thetaRad) + center.x;\n    const newY = (point.x - center.x) * Math.sin(thetaRad) + (point.y - center.y) * Math.cos(thetaRad) + center.y;\n    return new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](newY, newX);\n  }\n  static construct_t(triangles) {\n    const startingPoints = triangles[0].disjointPoints(triangles[1]);\n    if (startingPoints.length != 1) {\n      return null;\n    }\n    return Funnel.searchPath(triangles);\n  }\n  static calculateBisectorPoints(pointA, pointB, pointC, length) {\n    const vectorAB = new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](pointB.y - pointA.y, pointB.x - pointA.x);\n    const vectorBC = new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](pointC.y - pointB.y, pointC.x - pointB.x);\n    const bisector1 = Funnel.calculateBisectorVector(vectorAB, vectorBC);\n    const bisectorPoint1 = Funnel.extendPoint(pointB, bisector1, length);\n    return [bisectorPoint1, Funnel.rotatePoint(bisectorPoint1, pointB, 180)];\n  }\n  static calculateBisectorVector(v1, v2) {\n    const angle1 = Math.atan2(v1.y, v1.x);\n    const angle2 = Math.atan2(v2.y, v2.x);\n    const bisectorAngle = (angle1 + angle2 + Math.PI) / 2;\n    return new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Math.sin(bisectorAngle), Math.cos(bisectorAngle));\n  }\n  static extendPoint(point, vector, length) {\n    return new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](point.y + vector.y * length, point.x + vector.x * length);\n  }\n  static constructBisectorsArray(funnel) {\n    let bisectors = [];\n    let points = funnel.lines;\n    for (let i = 0, c = points.length - 1; i < c; i++) {\n      let pointA = points[i],\n        pointB = points[(i + 1) % c],\n        pointC = points[(i + 2) % c];\n      let bisectorPoints = Funnel.calculateBisectorPoints(pointA, pointB, pointC, 0.01);\n      for (let j = 0; j < 2; j++) {\n        if (funnel.isPointInsidePolygon(bisectorPoints[j])) {\n          bisectors.push(new _Geometry_Line_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](pointB, bisectorPoints[j]));\n          break;\n        }\n      }\n    }\n    return bisectors;\n  }\n  static construct(triangles) {\n    if (!triangles.length) {\n      return null;\n    }\n    if (triangles.length == 1) {\n      return new _Geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](triangles[0].a, triangles[0].b, triangles[0].c);\n    }\n    return Funnel.construct_t(triangles);\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Funnel);\n\n//# sourceURL=webpack://polygon-pathfinding/./Searcher/Funnel.js?");

/***/ }),

/***/ "./Searcher/Heap.js":
/*!**************************!*\
  !*** ./Searcher/Heap.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Heap {\n  constructor(heapComparer) {\n    this.heap = [];\n    this.heapComparer = heapComparer;\n  }\n  push(value) {\n    this.heap.push(value);\n    this.heapifyUp();\n  }\n  top() {\n    if (!this.heap.length) {\n      return null;\n    }\n    return this.heap[0];\n  }\n  size() {\n    return this.heap.length;\n  }\n  pop() {\n    if (this.heap.length === 0) {\n      return null;\n    }\n    if (this.heap.length === 1) {\n      return this.heap.pop();\n    }\n    const top = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.heapifyDown();\n    return top;\n  }\n  heapifyUp() {\n    let index = this.heap.length - 1;\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      if (this.heapComparer(this.heap[index], this.heap[parentIndex])) {\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n  heapifyDown() {\n    let index = 0;\n    while (true) {\n      const leftChildIndex = 2 * index + 1;\n      const rightChildIndex = 2 * index + 2;\n      let smallestChildIndex = index;\n      if (leftChildIndex < this.heap.length && this.heapComparer(this.heap[leftChildIndex], this.heap[smallestChildIndex])) {\n        smallestChildIndex = leftChildIndex;\n      }\n      if (rightChildIndex < this.heap.length && this.heapComparer(this.heap[rightChildIndex], this.heap[smallestChildIndex])) {\n        smallestChildIndex = rightChildIndex;\n      }\n      if (index !== smallestChildIndex) {\n        [this.heap[index], this.heap[smallestChildIndex]] = [this.heap[smallestChildIndex], this.heap[index]];\n        index = smallestChildIndex;\n      } else {\n        break;\n      }\n    }\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Heap);\n\n//# sourceURL=webpack://polygon-pathfinding/./Searcher/Heap.js?");

/***/ }),

/***/ "./Searcher/Search.js":
/*!****************************!*\
  !*** ./Searcher/Search.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _AStar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AStar.js */ \"./Searcher/AStar.js\");\n/* harmony import */ var _Funnel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Funnel.js */ \"./Searcher/Funnel.js\");\n/* harmony import */ var _Geometry_Line_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Geometry/Line.js */ \"./Geometry/Line.js\");\n/* harmony import */ var _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Geometry/Point.js */ \"./Geometry/Point.js\");\n\n\n\n\nclass Search {\n  constructor(polygon) {\n    this.polygon = polygon;\n    if (this.polygon) {\n      this.navmesh = polygon.navmesh;\n    }\n    this.aStar = new _AStar_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](triA => triA.neighbours, triA => {\n      return triA.id;\n    }, (triA, triB) => triA.midDistance(triB));\n  }\n  search(src, dst) {\n    return this.aStar.search(src, dst);\n  }\n  getNextPoint(currentPoint, currentIndex, triangles) {\n    let index = currentIndex;\n    for (let i = currentIndex, c = triangles.length; i < c; i++) {\n      if (!this.polygon.doesSegmentIntersects(currentPoint, triangles[i].midPoint())) {\n        index = i;\n        continue;\n      }\n      break;\n    }\n    return index;\n  }\n  printBisector(bisector) {\n    console.log(`(${bisector.pointA.y},${bisector.pointA.x}),(${bisector.pointB.y},${bisector.pointB.x})`);\n  }\n  searchFunnelPoints_t(funnel, bisectors, src, dst) {\n    let searchAlgo = new _AStar_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bisector => {\n      let neigh = [];\n      for (let i = 0, c = bisectors.length; i < c; i++) {\n        if (!funnel.doesSegmentIntersects(bisector.pointB, bisectors[i].pointB)) {\n          neigh.push(bisectors[i]);\n        }\n      }\n      if (!funnel.doesSegmentIntersects(bisector.pointB, dst.pointB)) {\n        neigh.push(dst);\n      }\n      return neigh;\n    }, bisector => {\n      return bisector.id;\n    }, (bisectorA, bisectorB) => bisectorA.pointB.distancef(bisectorB.pointB));\n    return searchAlgo.search(src, dst);\n  }\n  searchFunnelPoints(funnel, src, dst) {\n    let bisectors = _Funnel_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].constructBisectorsArray(funnel);\n    return this.searchFunnelPoints_t(funnel, bisectors, new _Geometry_Line_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](-5, -5), new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](src.y, src.x)), new _Geometry_Line_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](-5, -5), new _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](dst.y, dst.x)));\n  }\n\n  // to modify this\n  getPointsPathFromTriangle(srcTriangle, dstTriangle, src, dst) {\n    let triangles = this.search(srcTriangle, dstTriangle);\n    let funnel = _Funnel_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].construct(triangles);\n    let pointsFoundInPath = this.searchFunnelPoints(funnel, src, dst);\n    if (!pointsFoundInPath) {\n      return null;\n    }\n    let pathPoints = [];\n    for (let i = 0, c = pointsFoundInPath.length; i < c; i++) {\n      pathPoints.push(pointsFoundInPath[i].pointB);\n    }\n    return pathPoints;\n  }\n  getPointsPath(src, dst) {\n    const triangleSrc = this.polygon.getTriangle(src);\n    if (!triangleSrc) {\n      return null;\n    }\n    const triangleDst = this.polygon.getTriangle(dst);\n    if (!triangleDst) {\n      return null;\n    }\n    return [src, ...this.getPointsPathFromTriangle(triangleSrc, triangleDst, src, dst), dst];\n  }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Search);\n\n//# sourceURL=webpack://polygon-pathfinding/./Searcher/Search.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* reexport safe */ _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   Polygon: () => (/* reexport safe */ _Geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Search: () => (/* reexport safe */ _Searcher_Search_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _Geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry/Polygon.js */ \"./Geometry/Polygon.js\");\n/* harmony import */ var _Geometry_Point_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Geometry/Point.js */ \"./Geometry/Point.js\");\n/* harmony import */ var _Searcher_Search_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Searcher/Search.js */ \"./Searcher/Search.js\");\n\n\n\n\n\n//# sourceURL=webpack://polygon-pathfinding/./index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;